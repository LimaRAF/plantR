% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nameMatching.R
\name{nameMatching}
\alias{nameMatching}
\title{Name Matching Against Reference}
\usage{
nameMatching(
  names = NULL,
  ref.names = NULL,
  match.type = c("exact", "fuzzy"),
  clean.names = FALSE,
  dist.method = "jw",
  p = 0.1,
  max.dist = 0.25,
  split.letters = FALSE,
  parallel = FALSE,
  cores = 2,
  show.progress = FALSE
)
}
\arguments{
\item{names}{a vector of input names to be compared against a
reference}

\item{ref.names}{a vector of the names of reference}

\item{match.type}{type of match: exact, fuzzy or both. Defaults to
both.}

\item{clean.names}{logical. Should spaces, punctuation, symbols and
species characters be removed prior to name matching? Defaults to
FALSE.}

\item{dist.method}{fuzzy matching algorithm to be passed on to
\code{stringdist::amatch()}. Defaults to "jw" (i.e. Jaro-Winkler)}

\item{p}{numeric. Weight of the shared prefix when \code{method} is
'jw'. Defaults to 0.1.}

\item{max.dist}{no match is returned when name distance is larger
than \code{max.dist}. Note that this argument depends on the
\code{dist.method} specified. Defaults to 0.25, which is a rather
inclusive threshold.}

\item{split.letters}{logical. Should fuzzy matching be performed
separately by the input and reference name initials? Defaults to
FALSE}

\item{parallel}{logical. Should fuzzy matching be performed in
parallel? Defaults to FALSE}

\item{cores}{integer. The number of cores for parallel execution.
Two by default.}

\item{show.progress}{logical. Whether fuzzy matching progress
should displayed. Defaults to FALSE}
}
\value{
a vector with the indices (i.e. positions) of the matches
of the input \code{names} in \code{ref.names}
}
\description{
Performs the exact and fuzzy matching between two sets
of names (input and reference), based on cleaned names or on
indexes. To speed up computational time for larger datasets, the
function can parallelize the matching processes and/or perform
matching by initial letters.
}
\details{
By default, the argument 'clean.names' is FALSE, to increase
computaional speed. However, both exact and fuzzy matches are case,
space and punctuation sensitive. So, cleaning names (i.e. seting
'clean.names' to TRUE) can substantially increase the number of
matches. See the internal function \code{cleanName()} on how this
cleaning is performed.

If 'split.letters' is TRUE, then the matching is done by chunks
composed by the initial letter of both input and references names.
If 'split.letters' and 'parallel' are both TRUE, matching is also
parallelized which is important in terms of computational time when
dealing with larger vectors (i.e. above tens of thousands names).

If 'split.letters' is FALSE and 'parallel' is TRUE, then the
matching is done by chunks of input names. The size of the chunks
is arbitrarily defined by the number defined in the argument
'cores' (two by default). If 'split.letters' and 'parallel' is
FALSE, then the matching is done using all input and reference
names together.

The 'parallel' option is currently only implemented for fuzzy
matches. For the majority of cases, exact matching should be quite
fast.
}
\examples{
# example code
names <- c("Ailton", "Highlander", "Hell", "Hallo", "Agnes-Lee")
refs <- c("Agnes Lee", "Hell", "Hellinger", "Hello", "Hill", "Hilton")

refs[nameMatching(names, refs)]
refs[nameMatching(names, refs, match.type = c("exact"))]
refs[nameMatching(names, refs, match.type = c("exact"), clean.names = FALSE)]
refs[nameMatching(names, refs, max.dist = 0.15)]
refs[nameMatching(names, refs, split = TRUE)]


}
\author{
Renato A. Ferreira de Lima
}
