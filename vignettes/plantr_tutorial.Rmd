---
title: "plantR Tutorial"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_vignette:
        toc: true
        number_sections: true
    md_document:
      variant: gfm
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{plantR tutorial}
  %\VignetteEngine{knitr::rmarkdown}
    \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval = FALSE}
devtools::load_all() # for development
```

# Introduction

This tutorial provides basic explanations on the functions related to data download, editing and validation using `plantR`. For each of these steps, there is a more specific tutorial presenting all functionalities more in detail (see package vignettes).

Let's first install and load the package from [CRAN](https://CRAN.R-project.org) with:

```{r, eval = FALSE}
install.packages("plantR")
library(plantR)
```

or from [GitHub](https://github.com) with:
```{r, eval = FALSE}
library("devtools")
install_github("LimaRAF/plantR")
library("plantR")
```


# Data entry

You can download species occurrence data directly from R, using the functions provided by `plantR` or by other R packages. For this tutorial, we are going to use the `plantR` function `rspeciesLink`, which downloads data from [CRIA](http://www.cria.org.br/) (Centro de Referência em Informação Ambiental). For a detailed tutorial of how to download data from different sources, check a more detailed tutorial [here](#INCLUDE HERE LINK TO SARA'S DETAILED TUTORIAL). 

You can also use .csv files containing personal data or data downloaded manually from online data repositories, as long as the column names match those accepted by `plantR` (e.g. DarwinCore). See function `fixField()` below for more details on standard columns names.
	
## Downloading occurrence data with `plantR`

We will use as an example a dataset downloaded from speciesLink, using the function `rspeciesLink`, which allows a variety of ways on how to search for data. In this tutorial, we will use data for two common Neotropical trees:

```{r, eval = FALSE}
spp <- c("Trema micrantha",
        "Casearia sylvestris")
```

After defining the species name we want to obtain occurrence data, we proceed to the download itself. Here, we will use only herbarium plant specimens (i.e. vouchers) for the names listed above, including the list of synonyms accepted in the Brazilian Flora 2020 project (this may take a few minutes):

```{r, eval = FALSE}
example <- rspeciesLink(scientificName =  spp,
                     Scope = "plants",
                     basisOfRecord = "PreservedSpecimen",
                     Synonyms = "flora2020")

```

The occurrence data is now stored in the object `example`. We can inspect how many occurrences were downloaded:

```{r, eval = FALSE}
dim(example$data)
```

If the data download is taking too long, you can use the result of the same search performed in June 2020 and stored within `plantR` using the command `data(example)`.


# Data processing

## Preparing the input data: function `fixField()`

Before we can start to process the input data, we need to be sure that our input data has all the required fields and that they are in the required format.

We use the function `fixField()` to set up the required and optional fields and to drop fields without essential information for the data processing and validation. We save the output of the function in an object with a different name ('occs').

```{r, eval = FALSE}
occs <- fixField(example$data, origin = "splink")
```

Note that the function returns some warning messages. It is **very** important to carefully understand these warnings before we can continue. 

The first warning says that the name of the column header 'scientifname', provided in the input data, was replaced by the standard name 'scientificName', the standard name used by `plantR`. The second warning also reports that a header name was replaced by a standard header name, 'occurrenceID' in this case. The third warning is less important because it relates to optional fields. The last warning is more important, since they may indicate typos in the names of important headers.

## Standardizing people names, collector number and dates: function `formatOcc()`

Particularly when working with data coming from multiple secondary sources, it is important to standardize the notation used by different collections and sometimes by different collectors within the same collection.

We first create the new columns that will receive the edited fields.

```{r, eval = FALSE}
occs$recordedBy.new = occs$recordedBy
occs$recordNumber.new = occs$recordNumber
occs$identifiedBy.new = occs$identifiedBy
occs$year.new = occs$year
occs$yearIdentified.new = occs$yearIdentified
```

The year of collection is sometimes stored on the field 'eventDate' and not on the field 'year'. In this case, we should replace all missing information from the field 'year' by the information stored in the field 'eventDate'. Since this is not the case here, we process to the next data processing step.

We then prepare the new fields we created using functions `fixName()`, `colNumber()` and `getYear()`. We chose to remove all species characters from authors and identicador names (argument `special.char = FALSE`), which is the indicated option for further data processing and validation. We also set the characters that will represent occurrences without number of collection ("s.n.") and without the year of collection and identification ("n.d.").  

```{r, eval = FALSE}
occs$recordedBy.new = unlist(lapply(occs$recordedBy.new, fixName, special.char = FALSE))
occs$recordNumber.new = unlist(lapply(occs$recordNumber.new, colNumber, noNumb = "s.n."))
occs$identifiedBy.new = unlist(lapply(occs$identifiedBy.new, fixName, special.char = FALSE))
occs$year.new = unlist(lapply(occs$year.new, getYear, noYear = "n.d."))
occs$yearIdentified.new = unlist(lapply(occs$yearIdentified.new, getYear, noYear = "n.d."))
```

Next, we format the names of the collector and identificator (function `formatName()`)
```{r, eval = FALSE}
occs$recordedBy.new = unlist(lapply(occs$recordedBy.new, formatName))
occs$identifiedBy.new = unlist(lapply(occs$identifiedBy.new, formatName))
```

We then separate first and auxiliary names for multiple names and then convert them to the TDWG format (function `tdwgNames()`). To do so, we set the argument 'out' of function `tdwgNames()` to "aux" and "first" (by default `tdwgNames()` edits and returns all names from multiple name strings).

We also define that the symbol that will separate different names, which in our example will be a semi-colon followed by a space.

```{r, eval = FALSE}
occs$recordedBy.aux = unlist(lapply(occs$recordedBy.new, tdwgNames, out = "aux", sep.out = "; "))
occs$identifiedBy.aux = unlist(lapply(occs$identifiedBy.new, tdwgNames, out = "aux", sep.out = "; "))
occs$recordedBy.new = unlist(lapply(occs$recordedBy.new, tdwgNames, out = "first"))
occs$identifiedBy.new = unlist(lapply(occs$identifiedBy.new, tdwgNames, out = "first"))
```

We can inspect what is the result of this separation between first and auxiliary names:
```{r, eval = FALSE}
head(occs[,c("recordedBy","recordedBy.new","recordedBy.aux")], 3)
```

It is also useful for the validation process to standardize the notation for missing collector and identificator names. To do so, we use the function `missName()` and again we set missing names as "s.n.".

```{r, eval = FALSE}
occs$recordedBy.new = missName(occs$recordedBy.new, type = "collector", noName = "s.n.")
occs$identifiedBy.new = missName(occs$identifiedBy.new, type = "identificator", noName = "s.n.")
```

For some of the operations we will perform, it is also useful to extract the last name of the first collector, that is stored in our formated field 'recordedBy.new'.

```{r, eval = FALSE}
occs$last.name = unlist(lapply(occs$recordedBy.new, lastName, noName = "s.n."))
```

We can inspect what these functions are doing by comparing the original and edit columns (only the first 15 records)

```{r, eval = FALSE}
head(cbind(occs$recordedBy, occs$recordedBy.new, occs$recordedBy.aux), n = 15)
head(cbind(occs$recordedBy, occs$last.name), n = 15)
head(cbind(occs$identifiedBy, occs$identifiedBy.new), n = 15)
head(cbind(occs$year, occs$eventDate, occs$year.new), n = 15)
head(cbind(occs$yearIdentified, occs$yearIdentified.new), n = 15)
```

These functions handle well most formats, but not all of them  (e.g. name format 'A. Custódio, Filho' or date format "Jul-02"). However, this standardization will be very useful for the search of duplicated specimens across herbaria (see below).

All the previous steps are important to understand the edtiton of each field. But, `plantR` can execute all these steps at once using the wrapper function `formatOcc()`:

```{r, eval = FALSE}
occs1 = fixField(example$data, origin = "splink")
occs1 = formatOcc(occs1)
```

Let's compare if the output of the two approaches are the same, column by column:

```{r, eval = FALSE}
table(occs$recordedBy.new == occs1$recordedBy.new)
table(occs$identifiedBy.new == occs1$identifiedBy.new)
table(occs$year.new == occs1$year.new)
table(occs$yearIdentified.new == occs1$yearIdentified.new)
table(occs$last.name == occs1$last.name)
rm(occs1)
```

Yes! So, the new data frame created contain the original and edited/formatted information regarding the name of the collector and of the identificator, the dates of collection and identification, and number of collection. 


## Editing locality information: function `formatLoc()`

One important step to find missing geographical coordinates and to validate those coordinates provided with the occurrence is to standardize the fields containing locality information, namely "country", "stateProvince", "municipality" and "locality".

`plantR` have a function to edit and standardize locality fields: function `fixLoc()`. By default, this function formats all four locality fields simultaneously (returns the entry data.frame with the new columns), but the user can choose one field at a time by changing the function argument 'admin.levels' (in this case, the function returns a vector). However, some of the editing processes become more complete if all the information is available for the four fields.

To exemplify, we will use all locality fields:

```{r, eval = FALSE}
occs  = fixLoc(occs, admin.levels = c("country","stateProvince","municipality","locality"), scrap = TRUE)
```
Note that we performed the editing of the locality fields using the argument `scrap = TRUE`. This argument controls the search for missing information from the field locality (i.e. text mining). It also performs some extra editing and cropping of the locality field in order to obtain more standardized locality descriptions. If the country, state and municipality fields are given, they remain unaltered. Only missing information in these fields are completed by the editing and scrapping process.

Although the search for missing localities generally results in no empty fields (i.e. NAs), it does not mean that the information retrieved from this search is accurate. It depends if the information is actually available in the field 'locality' and how it is arranged. To make sure that the missing information obtained is indeed a locality, we need to cross it with a gazetteer. In `plantR` the search for missing information from a gazetteer is based on a standard locality string. This string simply is the concatenation of the country, state, municipality and locality fields, at the best resolution available. This string is created using the function `strLoc`:

```{r, eval = FALSE}	
locs = strLoc(occs)
head(locs, 5)
```

If the municipality exists for a given state and country, then it is deemed as being a good locality name, and the locality string associated with it is given priority for the validation of the locality information (see below). If there is missing information, than the alternative locality string (obtained using argument `scrap` of function `fixLoc`) is used in a final attempt to search for missing information in the gazetteer. If these alternatives do not work, than the upper administrative level available is used as the reference locality information. 

The notation of locality information varies a lot, and there are many mistakes regarding the notation of some localities (e.g. "Balneário do Camboriú" instead of "Balneário Camboriú"). Therefore, it is useful to further simplify the locality strings, by reducing all name variants into the same locality string. This simplification is performed by the function `prepLoc`:

```{r, eval = FALSE}	
locs$loc.string  = prepLoc(locs$loc.string) # priority string
locs$loc.string1  = prepLoc(locs$loc.string1) # alternative string
locs$loc.string2  = prepLoc(locs$loc.string2) # alternative string
```

After the construction and simplification of the locality strings, we can finally cross it with the gazetteer, using function `getLoc`.

```{r, eval = FALSE}	
locs  = getLoc(locs, gazet = "plantR")
```	

Some of the locality strings were retrieved in the default `plantR` gazetteer at the locality level (e.g. park, farm). The gazetteer is more complete for Latin America and has much more information at the locality level for Brazil. Therefore, info retrieval at the locality level should be biased towards specimens collected in Brazil. You can use the argument `gazet` to use your personal gazetteer instead of `plantR` default, as long as it contains the same fields. Note that the function also returns the geographical coordinates from the gazetteer. Note as well that the edited version of the localities is different from the original localities regarding their resolution (see details in the next section, 'Data validation').  

Finally, we merge the data frame with the previous data processing (function `formatOcc()`) with the output of the locality data processing:

```{r, eval = FALSE}	
occs = cbind.data.frame(occs, locs[,c("loc","loc.correct","latitude.gazetteer","longitude.gazetteer","resolution.gazetteer")])
```	

Finally, it can be useful to trace back the full names of the localities retrieved from the gazetteer. 
This can be performed using the function `getAdmin`, which returns the names of the subdivisions of each locality:

```{r, eval = FALSE}	
head(getAdmin(occs))
```


## Editing geographical coordinates: function `formatCoord()`

Previous to the validation of the original geographical coordinates, it is important to make sure that they are given and if they are in the required format: non-zero, non-NA [decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees), with decimal digits separated by points.

```{r, eval = FALSE}	
occs = prepCoord(occs)
```	

Geographical coordinates are often missing or are provided in a format that the function `prepCoord` cannot convert to decimal degrees. For the dataset we are using in this tutorial, we can inspect the proportion of occurrences without geographical coordinates: 

```{r, eval = FALSE}	
table(!is.na(occs$decimalLatitude.new))/dim(occs)[1]
```	

As we can see, 20% of the occurrences records have no coordinates. Therefore, one may want to use the coordinates obtained from the gazetteer to replace the missing coordinates. In `plantR` we use the function `workCoord` to do this procedure. This function also flags the origin and the probable resolution of the original coordinates: 

```{r, eval = FALSE}	
occs = workCoord(occs)
table(!is.na(occs$decimalLatitude.new))/dim(occs)[1]
```	

Now, missing coordinates were obtained from a gazetteer and there is a coordinate at the best resolution available for almost all occurrences.


## Editing species names: function `formatTax()`

Suggestion of items adapted from the original workflow:
4.0 Firt editing (flag indets, class taxon rank, remove authors)
4.1 Remove cf. e aff. (and create a clomun for the name modificators?)
4.2 Option to consider or not names at infraspecific level at specific level (e.g. remove ‘var.’, ‘subsp.’, ‘forma’, etc)
4.3 Standardize the nomenclature (typos, synonyms and ortographical variants) -> Data editing or Data Validation??
4.4 Edit family names to APG (plantR function `formatFamily`: step currently done using ‘flora’ and taxonStand packages)

### Species names format 
Although we downloaded occurrences for only two species names (i.e.
\italic{Trema micrantha} and \italic{Casearia sylvestris}), the function
`rspeciesLink` returned (as required) all synonyms accepted by the Brazilian
Flora 2020 (\url{http://floradobrasil.jbrj.gov.br/reflora/listaBrasil}) were
also downloaded. In addition, the speciesLink network
(\url{http://splink.cria.org.br/}) stores the information as provided by the
collections, which may vary in the way the scientific names are stored. For data
downloaded from GBIF (\url{https://www.gbif.org/}) this step may be unnecessary
since GBIF already stores data in a more standardized way.

```{r, eval = FALSE}	
sort(table(occs$scientificName))
```

There are many R packages that edit taxonomical information (e.g. `taxize` or
`Taxonstand`). For species listed in the Brazilian Flora 2020, the package `flora` provides
different tools to format and validate plant species names, folllowing the accepted nomenclature of the Brazilian Flora 2020 project. We will use it to do some formatting of species names.

```{r, eval = FALSE}
install.packages("flora")
library(flora)
occs$scientificName.new <- sapply(occs$scientificName, trim)
occs$scientificName.new <- sapply(occs$scientificName.new, standardize.names)
occs$scientificName.new <- sapply(occs$scientificName.new, remove.authors)
```

In `plantR` we offer a new function that perform all these step and an extra step, which is the extraction
of the name modificators: "cf." and "aff.":

#### FUNCTION TO BE CREATED? SARA/ANDREA, VCS JÁ TEM ALGO NESSA LINHA? QUAL O PADRÃO DARWINCORE NESSES CASOS?
```{r, eval = FALSE}
occs$scientificName.new <- gsub(" cf\\. | aff\\. ", " ", occs$scientificName.new)
```

### Species names spelling

#### CHECK HERE: SÓ INCLUI AQUI UMA IMPROVISAÇÃO PARA PENSARMOS NO TUTORIAL... ACHO QUE VCS JÁ DEVEM TER ALGO NESSA LINHA...
The package `flora` and other packages provide tools to find typos in species names:
```{r, eval = FALSE}
name.list <- sapply(unique(occs$scientificName.new), suggest.names, max.distance = 0.85, return.na = TRUE)
name.list <- name.list[!is.na(name.list) & !names(name.list) %in% name.list]
for(i in 1:length(name.list)) occs$scientificName.new <- replace(occs$scientificName.new, grep(paste0("^",names(name.list)[i],"$"), occs$scientificName.new), name.list[i])
```

### Taxon rank

#### REMOVE/STANDARDIZE INFRA-SPECIFIC RANKS?


# Data validation

In `plantR`, all validation steps add new columns to the occurrence data,
flagging possible problems. Depending on the study aims and spatial scale, one
can choose to try to correct some of the problems or drop them from the final
data set.

## Locality validation: function `validateLoc()`

The editing process of locality information and its comparison against the gazetteer, return the localities (and coordinates) at the best resolution available. In this comparison, much information provided at the locality level is only retrieved at the municipality level, which is expected due to the completeness of the gazetteer used (not all localities are stored in the standard `plantR` gazetteer). But many of them are only retrieved at state/province level, meaning that fields containing state and municipality information may need to be checked. 

In `plantR` the resolution of the locality information provided with the specimen and the one found in the gazetteer is described using the function `validateLoc`, which compares the two resolutions and store the result of this comparison in a new column called 'loc.check': 

```{r, eval = FALSE}
occs = validateLoc(occs)
table(occs$loc.check)
```	
In this column, specimens for which the locality provided could not be found in
the gazetteer at the same resolution are flagged with a "check_...". In these
cases, the locality resolution is downgraded until a locality is found in the
gazetteer. In the case that even the country is not found, then the locality is
flagged as "no_info". We also flag all the specimens that retained their
resolution (i.e. "ok_same_resolution") and those that could be retrieved at a better
locality resolution, also flagged with an "ok_" (e.g. 'ok_state2municipality':
'stateProvince' level that is now at the 'municipality' level).

Note that many occurrences were flagged with a "check_...". The class "check_local.2municip."
should not be a problem, since the internal `plantR` gazetteer does not contain a comprehensive
list of names at the locality level. However, other "check_..." classes (e.g. "check_local.2country") may indicate missing information or typos that may need some more careful inspection.


## Geographical validation: function `validateCoord()`

Check here other possible steps that can use coordinateCleaner or other packages

### Flag occurrences from cultivated individuals

### Load and inspect the `plantR` default world map

### Validate original coordinates at country, state and county level

### Coordinates falling into the sea or bays

### How distant original coordinates are from the county centroid?

### Verification of inverted and swaped coordinates

### Flagging based on coordinate resoltuion and distance from the target county

### Replacing coordinates accordin to the verified classes 


## Taxonomic validation: function `validateTax()`

### Species synonyms

#### REVER AQUI: CRIAR FUNCOES? SINONIMOS É FORMATAÇÃO OU VALIDAÇÃO DOS NOMES?? 
```{r, eval = FALSE}
synonyms <- get.taxa(unique(occs$scientificName.new), suggestion.distance = 0.85, drop = NULL)
synonyms <- synonyms[synonyms$notes %in% "replaced synonym",]
for(i in 1:length(synonyms)) occs$scientificName.new <- gsub(paste0("^", synonyms$original.search[i],"$"), synonyms$search.str[i], occs$scientificName.new, perl = TRUE)
```

Note that there are more species names than the ones used to search for occurences. Some are due to name format and other are due to differences in the assignnemt of synonyms between speciesLink and the Brazilian Flora interface used here, the package `flora`.

### Botanical family synonyms and standardization (function `formatFamily`)
The classification of the taxonomic confidence in species determination of each
occurrence is currently performed based on a global list of taxonomists per
family (see details below). Because different plant classification systems can
use different names to the same family, we need to standardize family names. The
standard used by `plantR` to obtain valid family names is the APG IV and the PPG
I, which can be obtained using the function `formatFamily`:

```{r, eval = FALSE}
occs = formatFamily(occs)
```

Note that the function return warnings in the case of conflicts on family names between the original occurrences and the APG IV/PPG I family list. Some are just differences in the list of names accepted from different classification systems, but some may represent errors.

### Confidence level of species determinations 
backup <- occs

Next step is to perform the classification of the species identification of each occurrence according to their taxonomic confidence level.

```{r, eval = FALSE}
occs = validateTax(occs)
table(occs$tax.check)/dim(occs)[1]
```

As expected, only ca. 15% of the specimesn were identified by a family specialist. Note that the function also returns a list with up to 10 names in the TDWG format that have more identifications. Maybe this name could represent a missing taxonomist from the database of taxonomists. If this is the case, one can add taxonomist to the validation using the argument `miss.taxonomist`:

```{r, eval = FALSE}
occs1 = validateTax(occs, miss.taxonomist = c("Salicaceae_Hatschbach, G.")
table(occs1$tax.check)/dim(occs)[1]
```
	
This is not the optimal example because Gerdt (Guenther) Hatschbach was not a Salicaceae specialist. However, he provided determinantions for many different families outside his speciality, often referred to as a generalist. There are some names of generalists in the `plantR` default taxonist database, and those names can be included in the taxonomic validation through the arguments `generalist`. However, this list of generalists is biased towards South America, particularly Brazil.


# Duplicated specimens (FUNCTIONS NOT CREATED YET)

## Prepare to merge: function `dupPrep()`
	
## Find duplicates across collections: function `dupSearch()`
	
## Homogenizing information within duplicates: function `dupInfo()`
	

# Data description  and summary (NEED TO CHECK)

### Number of collections, specimens and duplicates retrieved: 

### Number of families, genera and species retrieved: 

### Summary of flags and other issues
	
### Generating checklists

### Saving outputs to the format of other related packages

#### MODEL-R

#### ConR
