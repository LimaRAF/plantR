---
title: "plantR Tutorial"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_vignette:
        toc: true
        number_sections: true
    md_document:
      variant: gfm
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{plantR tutorial}
  %\VignetteEngine{knitr::rmarkdown}
    \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE, eval = TRUE}
devtools::load_all() # for development
```

# Introduction


plantR is an R package meant to format  <!-- ö acrescentar um objetivo mais   --> 
+ noisy data from collections +
+ gbif large totalizing project (bdd)

# Workflow overview 


This tutorial provides basic explanations on the functions related to data 
download, editing and validation using __plantR__. For each of these steps, there 
is a more specific tutorial presenting all functionalities more in detail (see 
package vignettes).

<!--Let's first install and load the package from [CRAN](https://CRAN.R-project.org) with:

```{r, eval = FALSE}
install.packages("plantR")
library(plantR)
```
-->

Let's first install and load the package from [GitHub](https://github.com) with:

```{r, eval = FALSE}
remotes::install_github("LimaRAF/plantR")
library("plantR")
```


# Data entry

You can download species occurrence data directly from R, using the functions 
provided by `plantR` or by other R packages. For this tutorial, we are going to 
use the `plantR` function `rspeciesLink()`, which downloads data from 
[CRIA](http://www.cria.org.br/) (Centro de Referência em Informação Ambiental). 
For a detailed tutorial of how to download data from different sources, check 
[here]<!--(#INCLUDE HERE LINK TO SARA'S DETAILED TUTORIAL). -->

You can also use .csv files containing your own data or data downloaded manually
from online data repositories, as long as the column names are named following 
DarwinCore standards. See function `fixField()` below for more details on 
standard columns names.
	
## Downloading occurrence data with `plantR`

We will use as an example a dataset downloaded from speciesLink, using the 
function `rspeciesLink()`, which allows a variety of ways on how to search for
data. In this tutorial, we will use data for (one/some) common Neotropical 
tree(s):

```{r, eval = TRUE}
#spp <- c("Trema micrantha",
#        "Myrcia splendens",
#        "Casearia sylvestris")
spp <- c("Trema micrantha")
```

After defining the species name we proceed to the download of occurrence data.
Here, we will use only herbarium plant specimens (i.e. vouchers) for the names 
listed above, including the list of synonyms accepted in the List of Species of
the Brazilian Flora 2020 project (this may take a few minutes):

```{r, eval = TRUE}
example <- rspeciesLink(scientificName =  spp,
                        Scope = "plants",
                        basisOfRecord = "PreservedSpecimen",
                        Synonyms = "flora2020")
```

The occurrence data is now stored in the object `example`. We can inspect how 
many occurrences were downloaded (`r nrow(example)` records and 
`r ncol(example)` fields):

```{r, eval = TRUE}
dim(example$data)
```

# Data processing

## Preparing the input data: function `fixField()`

Before we can start to process the input data, we need to be sure that our input
data has all the required fields and that they are in the required format.

We use the function `fixField()` to set up the required and optional fields and
to drop fields without essential information for the data processing and 
validation. We save the output of the function in an object with a different 
name (`'occs'`).

```{r, eval = TRUE}
occs <- fixField(example$data, origin = "splink")
names(occs)
```

Note that the function returns some warning messages. It is **very** important 
to understand carefully these warnings before we can continue. 

The first warning says that <!--the name of the column header 'scientifname', 
provided in the input data, was replaced by the standard name 'scientificName', 
the standard name used by `plantR`. The second warning also reports that--> a 
required header name (`'county'`) was replaced by a standard header name, 
`'municipality'` in this case.  <!-- porque dateIdentified se não está no names?-->
The third warning is less important because it relates to optional fields.  <!-- The 
last warning is more important, since it may indicate typos in the names of 
important headers. --> 

## Standardizing people names, collector number and dates: function `formatOcc()`

When working with data coming from multiple secondary sources, it is important 
to standardize the notation used by different collections and sometimes by 
different collectors within the same collection.

The year of collection is sometimes stored on the field 'eventDate' and not on 
the field 'year'. In this case, we should replace all missing information from 
the field 'year' by the information stored in the field 'eventDate'. Since this 
is not the case here, we process to the next data processing step.  <!-- checar isto --> 

We then prepare the new fields we created using functions `fixName()`, 
`colNumber()` and `getYear()`. We chose to remove all species characters from
authors and identifier names (argument `special.char = FALSE`), which is the
indicated option for further data processing and validation. We also set the 
characters that will represent occurrences without number of collection ("s.n.")
and without the year of collection and identification ("n.d.").  

```{r, eval = TRUE}
occs$recordedBy.new <- fixName(occs$recordedBy, special.char = FALSE)
occs$identifiedBy.new <-  fixName(occs$identifiedBy, special.char = FALSE)

occs$recordNumber.new <- colNumber(occs$recordNumber, noNumb = "s.n.")

occs$year.new <- getYear(occs$year, noYear = "n.d.")
occs$yearIdentified.new <- getYear(occs$yearIdentified, noYear = "n.d.")
```

Next, we format the names of the collector and identificator (function `formatName()`)
```{r, eval = TRUE}
head(occs$recordedBy.new)
occs$recordedBy.new <- formatName(occs$recordedBy.new)
head(occs$recordedBy.new)

head(occs$identifiedBy.new)
occs$identifiedBy.new <- formatName(occs$identifiedBy.new)
head(occs$identifiedBy.new)
```

We then separate first and auxiliary names for multiple names and then convert 
them to the TDWG format (function `tdwgNames()`). To do so, we set the argument 
`out` of function `tdwgNames()` to "aux" and "first" (by default `tdwgNames()` 
edits and returns all names from multiple name strings).

We also define that the symbol that will separate different names, which in our
example will be a semi-colon followed by a space.

```{r, eval = TRUE}
head(occs$recordedBy.new)
occs$recordedBy.aux <- lapply(occs$recordedBy.new, tdwgNames, out = "aux", sep.out = "; ")
occs$recordedBy.new <- lapply(occs$recordedBy.new, tdwgNames, out = "first")
head(occs$recordedBy.new)
head(occs$recordedBy.aux)


occs$identifiedBy.aux <- lapply(occs$identifiedBy.new, tdwgNames, out = "aux", sep.out = "; ")
occs$identifiedBy.new <- lapply(occs$identifiedBy.new, tdwgNames, out = "first")
```

We can inspect what is the result of this separation between first and auxiliary names:

```{r, eval = TRUE}
head(occs[,c("recordedBy","recordedBy.new","recordedBy.aux")], 3)
```

It is also useful for the validation process to standardize the notation for 
missing collector and identificator names. To do so, we use the function 
`missName()` and again we set missing names as "s.n.".

```{r, eval = TRUE}
occs$recordedBy.new <- missName(occs$recordedBy.new, type = "collector", noName = "s.n.")
occs$identifiedBy.new <- missName(occs$identifiedBy.new, type = "identificator", noName = "s.n.")
```

For some of the operations we will perform, it is also useful to extract the 
last name of the first collector, that is stored in our formatted field 
`recordedBy.new`.

```{r, eval = TRUE}
occs$last.name <- lapply(occs$recordedBy.new, lastName, noName = "s.n.")
```

We can inspect what these functions are doing by comparing the original and edit
columns (only the first 15 records)

```{r, eval = TRUE}
head(cbind(occs$recordedBy, occs$recordedBy.new, occs$recordedBy.aux), n = 15)
head(cbind(occs$recordedBy, occs$last.name), n = 15)
head(cbind(occs$identifiedBy, occs$identifiedBy.new), n = 15)
head(cbind(occs$year, occs$eventDate, occs$year.new), n = 15)
head(cbind(occs$yearIdentified, occs$yearIdentified.new), n = 15)
```

These functions handle well most formats but not all of them  (e.g. name format 
'A. Custódio, Filho' or date format "Jul-02"). However, this standardization 
will be very useful for the search of duplicated specimens across herbaria 
(see below).

All the previous steps are important to understand the editing process of each 
field. __plantR__ can execute all these steps at once using the wrapper function 
`formatOcc()`:

```{r, eval = TRUE}
occs1 <- fixField(example$data, origin = "splink")
occs1 <- formatOcc(occs1)
```

Let's compare if the output of the two approaches are the same, column by column:

```{r, eval = TRUE}
identical(occs$recordedBy.new, occs1$recordedBy.new)
identical(occs$identifiedBy.new, occs1$identifiedBy.new)
identical(occs$year.new, occs1$year.new)
identical(occs$yearIdentified.new, occs1$yearIdentified.new)
identical(occs$last.name, occs1$last.name)
rm(occs1)
```

Yes! So, the new data frame contains the original and edited/formatted 
information regarding the name of the collector and of the identificator, the
dates of collection and identification, and collection number. 

## Editing locality information: function `formatLoc()`

One important step to find missing geographical coordinates and to validate the 
coordinates provided with the occurrence is to standardize the fields containing
locality information, namely "country", "stateProvince", "municipality" and 
"locality".

__plantR__ has a function to edit and standardize locality fields: function 
`fixLoc()`. By default, this function formats all four locality fields 
simultaneously (returns the entry data.frame with the new columns), but the user
can choose one field at a time by changing the function argument 'admin.levels' 
(in this case, the function returns a vector). However, some of the editing 
processes become more complete if all the information is available for the four 
fields.

To exemplify, we will use all locality fields:

```{r, eval = TRUE}
occs <- fixLoc(occs, 
               admin.levels = c("country","stateProvince","municipality","locality"),
               scrap = TRUE)
```

Note that we performed the editing of the locality fields using the argument 
`scrap = TRUE`. This argument controls the search for missing information from 
the field locality (i.e. text mining). It also performs some extra editing and 
cropping of the locality field in order to obtain more standardized locality 
descriptions. If the country, state, and municipality fields are given, they 
remain unaltered. Only missing information in these fields is completed by the 
editing and scrapping process.

Although the search for missing localities generally results in no empty fields 
(i.e. NAs), it does not mean that the information retrieved from this search is 
accurate. It depends on the information being actually available in the field 
'locality' and how it is arranged. To make sure that the missing information 
obtained is indeed a locality, we need to crosscheck it with a gazetteer. In 
__plantR__, the search for missing information from a gazetteer is based on a 
standard locality string. This string simply is the concatenation of the country,
state, municipality and locality fields, at the best resolution available. This 
string is created using the function `strLoc()`:

```{r, eval = TRUE}	
locs <- strLoc(occs)
head(locs, 5)
```

If the municipality exists for a given state and country, then it is deemed as 
being a good locality name, and the locality string associated with it is given 
priority for the validation of the locality information (see below). If there is
missing information, then the alternative locality string (obtained using 
argument `scrap` of function `fixLoc()`) is used in a final attempt to search for 
missing information in the gazetteer. If these alternatives do not work, then 
the upper administrative level available is used as the reference locality 
information. 

The notation of locality information varies a lot, and there are many mistakes 
regarding the notation of some localities (e.g. "Balneário do Camboriú" instead
of "Balneário Camboriú"). Therefore, it is useful to further simplify the 
locality strings, by reducing all name variants into the same locality string. 
This simplification is performed by the function `prepLoc()`:

```{r, eval = TRUE}	
locs$loc.string  <- prepLoc(locs$loc.string) # priority string
locs$loc.string1 <- prepLoc(locs$loc.string1) # alternative string
locs$loc.string2 <- prepLoc(locs$loc.string2) # alternative string
```

After the construction and simplification of the locality strings, we can 
finally cross it with the gazetteer, using function `getLoc()`.

```{r, eval = TRUE}	
locs <- getLoc(locs, gazet = "plantR")
```	

Some of the locality strings were retrieved in the default `plantR` gazetteer at
the locality level (e.g. park, farm). The gazetteer is more complete for Latin 
America and has much more information at the locality level for Brazil. 
Therefore, info retrieval at the locality level should be biased towards 
specimens collected in Brazil. You can use the argument `gazet` to use your 
personal gazetteer instead of __plantR__ default, as long as it contains the 
same fields.  <!-- Which fields? does plantR standardize a foreing gazetteer?--> 
Note that the function also returns the geographical coordinates from the 
gazetteer. Note as well that the edited version of the localities is different 
from the original localities regarding their resolution (see details in the next
section, 'Data validation'). <!-- ö add link to section--> 

Finally, we merge the data frame with the previous data processing (function 
`formatOcc()`) with the output of the locality data processing:

```{r, eval = TRUE}	
occs <- cbind.data.frame(occs, locs[, c("loc","loc.correct","latitude.gazetteer","longitude.gazetteer","resolution.gazetteer")])
```	

Finally, it can be useful to trace back the full names of the localities 
retrieved from the gazetteer. This can be performed using the function 
`getAdmin()`, which returns the names of the subdivisions of each locality:

```{r, eval = TRUE}	
head(getAdmin(occs))
```


## Editing geographical coordinates: function `formatCoord()`

Previous to the validation of the original geographical coordinates, it is 
important to make sure that they are given and if they are in the required 
format: non-zero, non-NA [decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees),
with decimal digits separated by points.

```{r, eval = TRUE}	
occs <- prepCoord(occs)
```	

Geographical coordinates are often missing or are provided in a format that the 
function `prepCoord()` cannot convert to decimal degrees. For the dataset we are
using in this tutorial, we can inspect the proportion of occurrences without 
geographical coordinates: 

```{r, eval = TRUE}	
table(!is.na(occs$decimalLatitude.new))/dim(occs)[1]
```	

As we can see, 20% of the occurrences records have no coordinates. Therefore, 
one may want to use the coordinates obtained from the gazetteer to replace the 
missing coordinates. In __plantR__ we use the function `workCoord()` to do this
procedure. This function also flags the origin and the probable resolution of 
the original coordinates: 

```{r, eval = TRUE}	
occs <- workCoord(occs)
table(!is.na(occs$decimalLatitude.new))/dim(occs)[1]
```	

Now, there is a geographical coordinate at the best resolution available for 
almost all occurrences.


## Editing species names: function `formatTax()`

### Species names spelling, format/modificators and synonyms 


# Data validation

In __plantR__, all validation steps add new columns to the occurrence data,
flagging possible problems. Depending on the study aims and spatial scale, one
can choose to try to correct some of the problems or drop them from the final
data set.

## Locality validation: function `validateLoc()`

The editing process of locality information and its comparison against the 
gazetteer return the localities (and coordinates) at the best resolution 
available. In this comparison, much information provided at the locality level 
is only retrieved at the municipality level, which is expected due to the 
completeness of the gazetteer used (not all localities are stored in the
standard __plantR__ gazetteer). But many of them are only retrieved at 
state/province level, meaning that fields containing state and municipality
information may need to be checked. 

In `plantR` the resolution of the locality information provided with the 
specimen and the one found in the gazetteer is described using the function 
`validateLoc()`, which compares the two resolutions and store the result of this
comparison in a new column called `'loc.check'`: 

```{r, eval = TRUE}
occs <- validateLoc(occs)
table(occs$loc.check)
```	

In this column, specimens for which the locality provided could not be found in
the gazetteer at the same resolution are flagged with a "check_". In these
cases, the locality resolution is downgraded until a locality is found. If even
at the country level the locality is not found, then it is flagged as "no_info".
We also flag all the specimens that retained their resolution (i.e. "ok_same")
and those that could be retrieved at a better locality resolution, also flagged
with an "ok_" (e.g. 'ok_state2municipality': 'stateProvince' level that is now
at the 'municipality' level).


## Geographical validation: function `validateCoord()`


## Taxonomic validation: function `validateTax()`

### Confidence level of species determinations

	

# Duplicated specimens

## Prepare to merge: function `dupPrep()`
	
## Find duplicates across collections: function `dupSearch()`
	
## Homogenizing information within duplicates: function `dupInfo()`
	

# Data description 

## Number of collections, specimens and duplicates retrieved 
	
